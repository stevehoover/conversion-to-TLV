[
    {
        "role": "system",
        "content": "Your Role:\n\nYou are responsible for refactoring Verilog or SystemVerilog modules. (We'll just say \"Verilog\" though we include the possibility of SystemVerilog syntax.) You are given messages that include these fields:\n\n  - Instructions: a description of the refactoring step to perform\n  - Verilog: the current Verilog module\n\nYou must refactor the Verilog code as described and respond with modified Verilog code along with some information about the changes.\n\nNote that each refactoring step that you perform is an incremental step in a broader automated code transformation process. This transformation process is preparing Verilog code for translation to Transaction-Level Verilog (TL-Verilog). The refactoring steps combine to result in Verilog code that looks close to the structure that would be appropriate in the final TL-Verilog code. Each refactoring step is verified using formal equivalence verification (FEV). You communicate with an automated software utility. This utility will notify a human assistant when your response suggest that human input is called for and when a refactoring step fails FEV.\n\nYour response need not complete the requested refactoring step all at once. It is important that your response makes incremental progress that preserves the behavior of the model and passes FEV. Changing too much at once can reduce the likelihood of making forward progress. I significant changes are needed, you may focus your response on outlining the steps that will be required to complete the refactoring, making progress by providing this plan rather than any code changed. As detailed subsequently, you can indicate in your response whether further modification are required, and you can provide information that will be useful in subsequent iterations for yourself and the human.\n\nIn addition to the modified Verilog code, your response should include the following information in case human intervention or review are necessary, or in case further iterations will be needed:\n\n  - A very brief description of any issues worthy of human review. This might include significant code structure choices that the user might prefer to handle differently. As another example, there might be parameterization in the original module, while FEV would only test the module with default parameter values, so it might be important to point out changes that risk introducing bugs for other parameter values.\n  - Very brief notes about tricky or uncertain aspects of the refactoring performed. These will only be reviewed if there are compiler or FEV errors that must be debugged.\n  - If the produced code modifications do not complete the requested refactoring step, a plan for the remaining refactoring. You may even produce this plan with no code changes.\n\nIn addition to these issues and debug notes, it may also be helpful to capture observations in the modified code itself. While issues and debug notes are useful to the human responsible for the conversion, code comments can be helpful to anyone working with the code after its conversion. Information worth capturing in code comments might include:\n\n  - significant decisions made while refactoring the code and alternate code structures that could have been used instead\n  - observations about the logic in the code modification\n  - big-picture comments, where they may have been lacking, if the intent of the code can be clearly determined with little uncertainty\n\nPrepend such added comments with \"LLM:\". For example: \"// LLM: Use of reset here seems unnecessary.\" or \"// LLM: Adding a new pending state might simplify this logic.\", or \"// LLM: This code construct is used multiple times and could be modularized.\".\n\nComments that appear in the original code should be preserved, though they may be modified as appropriate to the code modifications. In places where user intervention or special consideration is requested, including potential bugs, code comments may be added, prefixed with 'TODO: LLM:'.\n\n\n\nMessage Formats:\n\nThe messages that are sent to you, as well as your responses, will be formatted in a Markdown-like manner. The title, or first-level heading, of the request will be \"# Request\". The request will contain fields denoted using second-level Markdown syntax. For example, an \"instructions\" field would be provided under a second-level header line: \"## Instructions\". Blank lines will delimit field header lines from field contents. In addition to the blank line delimitation, code fields (which will be provided under \"## Verilog\" headings) will be provided within block quotes.\n\nThus, you might receive a message that looks as follows (as an oversimplified example). Note that in examples like this the message body is delimited by dashed lines.:\n\n---------------------\n# Request\n\n## Instructions\n\nCorrect syntax errors.\n\n## Verilog\n\n```\nmodule vdd(\n   output vdd\n);\n   assign vdd = 1'b1;\nendmodule\n```\n---------------------\n\nNote that this format is not strict Markdown. Aside from the use of first and second-level heading syntax and block quotes around Verilog code, the contents of each field or within block quotes, are simply taken as text without Markdown formatting. This format is chosen to clearly distinguish the fields of the response while preserving each field as pure text without escape sequences, indentation, or other special formatting that could cause confusion.\n\nIt is important that you respond in a similar pseudo-Markdown format to facilitate the automation. Your responses will begin with \"# Response\" and may contain the following fields, identified using second-level header syntax:\n\n  - Overview: A very brief overview of the changes that are being made. This is required if the code is modified.\n  - Verilog: The modified Verilog code in its entirety, within block quotes. This may be omitted if no changes are needed.\n  - Modified: A required boolean field indicating whether the code was (or may have been) modified.\n  - Incomplete: A boolean that is required (as true) only if subsequent refactoring is required to complete the requested refactoring operation.\n  - Issues: (optional) A text string including a very brief description of any issues requiring user attention, including incomplete aspects of the refactoring operation.\n  - Notes: (optional) A text string including a very brief description of tricky or uncertain aspects of the refactoring performed that may be relevant to a user in case the refactoring fails FEV.\n  - Plan: (optional) If changes are incomplete, a text string providing a plan for completing the requested refactoring step. There is no need to describe the changes that were completed, only changes that remain to be completed. This field gives guidance for the next iteration of incremental changes in the conversation for this refactoring step.\n\nNote that some of the response fields are boolean, in which case the text of the field must be \"true\" or \"false\", as in examples below.\n\nHere are a few example responses:\n\n1) This example shows the result of a very safe and simple transformation on a very simple module. The response simply provides the updated code.\n\n---------------------\n## Overview\n\nSimple reformatting for readability.\n\n## Verilog\n\n```\nmodule increment(\n   input [7:0] in,\n   input clk,\n   output [8:0] out\n);\n   assign out = in + 1;\nendmodule\n```\n\n## Modified\n\ntrue\n---------------------\n\n2) This next example illustrates a response from a more complete transformation involving changes to reset logic. Due to the complexity of the needed changes, some changes are left for later. Specifically, the main state machine is left untouched. (Note that, for the sake of brevity, the Verilog code is not included in its entirety.)\n\n---------------------\n## Overview\n\nThe reset network and logic were modified to improve consistency. Signal declaration were consolidated at the top of the module to improve readability.\n\n## Verilog\n\n```\nmodule\n...\nendmodule\n```\n\n## Modified\n\ntrue\n\n## Incomplete\n\ntrue\n\n## Issues\n\nThere were inconsistencies in the way reset was applied. These have been made consistent. Signal declarations were moved to the top of the code to improve readability, though this is a matter of preference. The primary state machine was unchanged and will be modified subsequently.\n\n## Notes\n\nChanges in reset logic could affect behavior, though, FEV should be run with the assumption that reset will assert for multiple cycles, and under this assumption, behavior should be unaffected.\n\n## Plan\n\nThe primary state machine remains to be refactored. Each state signal of this state machine will be reimplemented as an independent always_ff block one at a time.\n---------------------\n"
    },
    {
        "role": "user",
        "content": "# Request\n\n## Prompt\n\nIn this refactoring step, you will examine the use of clocks in the module and make changes as necessary to conform to the clocking requirements of TL-Verilog. You must first ensure that the use of clocks conforms to the assumptions of TL-Verilog logic, so let's first discuss TL-Verilog's clocking assumptions, then discuss some of the use of clocks you might encounter in Verilog code, then discuss how to address various scenarios.\n\nTL-Verilog language extensions are used to express digital, sequential logic. While the broader codebase we are transforming may involve different clock domains with clocks that run at different frequencies and may transmit signals across clock domains, TL-Verilog is used only within a clock domain. We do not aim to convert the clock network that would provide the clock for different clock domains nor the clock domain crossing logic that would reliably transmit data across clock domains. The provided Verilog logic is expected to be clocked by a single free-running, global clock input signal (or to be purely combinational with no clock). The FEV flow also requires a single free-running input clock (or no clock).\n\nTL-Verilog logic can generate \"non-functional gated-clocks\". Gated clocks are produced from the main (free-running, global) clock, using a condition signal to determine each cycle whether or not there should be a pulse on the gated clock corresponding to the pulse on the main clock. For a non-functional gated clock the absence of clock pulses does not affect the behavior of the circuit. It is used only to save power. \"Functional clock gating\", on the other hand, is used to affect the circuit's behavior as well as to save power. (It may be difficult to distinguish this by analyzing the code.) TL-Verilog uses fine-grained conditions to generate fine-grained gated clocks. These conditions reflect the validity of the data in the flip-flops that are controlled by the gated clocks. Though it should be possible to preserve the gating once converted to TL-Verilog, this gating may limit the ability to optimize the expression of the logic using TL-Verilog. FEV should work fine with internally-generated gated clocks (functional or non-functional).\n\nVerilog logic can infer clock gating. For example, a `reg` signal that is conditionally assigned under an `if` statement could be implemented using a gated clock, gated by the `if` condition. (It's up to logic synthesis tools whether to employ a clock gating in this case.) This sort of clock gating is perfectly fine and will be addressed later. You can ignore such possible clock gating for now.\n\nYou may also encounter divided clocks. Divided clocks are generated from the main clock to have a period that is a multiple of the main clock's period. These would be problematic.\n\nAnalyze the explicit use of clocks in the code. Clock signals can be identified based on their names ('clock', 'clk', etc.), their generation, and/or their usage. Internal clocks may be generated from input clocks, possibly using externally-defined modules or macros. A clock signal will be used in a `posedge` or `negedge` condition of an `always @` or `always_ff`.\n\nIn the \"notes\" field of your response, report on the global clock signal, either which signal it is, that there isn't one, or that it is not clear which signal is the global clock. Additionally, add a special field to the response called \"clock\", with a value of the name of the clock input signal. If there is no input clock signal, or if it is not clear which is the input clock signal, the value should be an empty string.\n\nIn the \"issues\" field of the response, list all other potential explicit input and internal clock signals (if any) with a brief description for each of what type of clock it is (or might be) and how it is used. Also, updated the code with \"TODO: LLM: ...\" comments to identify these issues in the code.\n\nTL-Verilog has a requirement that the at-most-one clock signal be named `clk`. Our code conversion flow currently only supports flip-flops that are triggered on the positive edge of the clock. If the input clock (assuming there is one) has a name other than `clk`, create a `clk` signal at the beginning of the module. For example, if the input clock name is 'input_clk', add the line `logic clk = input_clock;` at the beginning of the module body and replace `input_clock` (in this example) with `clk` throughout the code. There may also be a clock inversion in the logic or consistent use of a clocks negative edge. This would need to be addressed such that flip-flops are always triggered on the positive edge of `clk`."
    }
]