[{
  "desc": "Three-space indentation",
  "prompt": "Each level of code scope in TL-Verilog is indented exactly three spaces. Tabs are not permitted. Update the line indentation to conform to this standard of three spaces of indentation and no tabs for its Verilog scopes, such as within `begin`/`end`.\n\nHere is some additional guidance. The module declaration as well as the \"endmodule\" should have no indentation. Any indentation of module parameter in the module definition may be left unchanged. The body of the module should have one level (three spaces) of indenstation. For multiline statements, lines after the first line of each statement must be indented, but this indentation does not have to be three spaces. It may be preserved from the original Verilog (if > 0). If the original code was not consistent with its indentation, you will make it consistently three spaces.",
  "substeps": [{
    "id": 1,
    "desc": "Three-space indentation",
    "prompt": "Each level of code scope in TL-Verilog is indented exactly three spaces. Tabs are not permitted. Update the line indentation to conform to this standard of three spaces of indentation and no tabs for its Verilog scopes, such as within `begin`/`end`.\n\nHere is some additional guidance. The module declaration as well as the \"endmodule\" should have no indentation. Any indentation of module parameter in the module definition may be left unchanged. The body of the module should have one level (three spaces) of indenstation. For multiline statements, lines after the first line of each statement must be indented, but this indentation does not have to be three spaces. It may be preserved from the original Verilog (if > 0). If the original code was not consistent with its indentation, you will make it consistently three spaces."
  }]
}, {
  "desc": "Code Normalization and Clock/Reset Analysis",
  "must_produce": ["clock", "reset", "reset_assertion"],
  "prompt": "Perform comprehensive code normalization for TL-Verilog conversion by standardizing clock/reset signals, separating combined declarations from assignments, and detecting non-synthesizable constructs.\n\n**Clock Analysis:**\nThe FEV flow requires a single free-running input clock (or no clock). Scan the code to identify the global clock signal. Most modules take a global clock as input for all sequential elements. If found, provide an extra output field \"clock\" with the signal name. For purely combinational modules, provide \"clock\" field value of \"NONE\".\n\nReport any problematic clocking in the \"issues\" field:\n- Internally generated clocks (including gated or divided clocks)\n- Multiple independent clocks\n- Clock signals identified by names ('clock', 'clk', etc.) or usage in posedge/negedge conditions\n- Any edge-triggered use of signals other than the global clock\n\nAdd \"TODO: LLM: ...\" comments to identify problematic clock generation or usage.\n\n**Reset Analysis:**\nIdentify the primary reset input signal and determine its assertion level. Include two extra output fields: \"reset\" (signal name) and \"reset_assertion\" (\"high\" or \"low\"). For purely combinational circuits, use \"NONE\" for both fields. If unclear, use \"UNKNOWN\".\n\nReport asynchronous reset usage as issues - these can be recognized by reset signals used in posedge/negedge conditions or flip-flop modules suggesting asynchronous reset.\n\n**Declaration Separation:**\nSeparate any combined logic/wire declarations and assignments into two statements:\n```verilog\nlogic y = a & b;  // Combined\n```\nbecomes:\n```verilog\nlogic y;          // Separated\ny = a & b;\n```\n\n**Non-Synthesizable Code Detection:**\nAnalyze for non-synthesizable, analog, and tri-state logic including:\n- Initial blocks, delay statements (#), simulation system tasks ($display, $stop)\n- Fork-join constructs, real/string data types\n- Assert/assume statements, dynamic memory allocation\n- Tri-state logic (Z-state) and analog modeling constructs\n\nAdd \"TODO: LLM: ...\" comments and report in \"issues\" field if found.",
  "substeps": [{
    "id": 2,
    "desc": "Clocking",
    "must_produce": ["clock"],
    "prompt": 
    "The FEV flow we are using in the refactoring process requires a single free-running input clock (or no clock). We cannot currently automate the conversion of a module with other clock inputs. Further, internally generated clocks can be problematic for conversion to TL-Verilog.
    +
    +In this refactoring step, you will scan through the Verilog code to understand and report on its use of clocks in the module. Most modules take a global clock as input and use it for all sequential elements (which primarily tend to be D-type flip-flops). If this is the case for this module, you will make no code changes and simply provide an extra output field, \"clock\", in your response, whose value is the name of the global clock input signal.
    +
    +It is also possible that the module is purely combinational and has no input clock signal(s). In this case, provide a \"clock\" field value of \"NONE\".
    +
    +In other cases, you may encounter more sophisticated clocking that could be problematic. Specifically, any use of a clock other than a global input clock could be problematic. You will report on these issues so the user can address them. In no circumstance will you make changes to the Verilog logic for this refactoring step. You may, however, add or modify code comments to capture your findings for the benefit of those who will work with the translated code. Let's discuss various scenarios you might encounter, how to recognize them, and how to best deal with them.
    +
    +Any code that generates a clock internally should be identified and reported as an issue. \"TODO: LLM: ...\" comments should be inserted to identify such code. This could include code that generates a clock for simulation using (non-synthesizable) delay statements, e.g. `@5 clk = ! clk`. It could also include code that generates an internal clock based on an input clock. This would include gated clocks and divided clocks, discussed next.
    +
    +Gated clocks might be generated in various ways. Verilog logic can infer clock gating implicitly. In this case, the gated clock is not explicitly declared as a signal. This is actually a case you don't need to worry about, but let me explain it so you know not to report on it. As an example, consider the following code:
    +
    +```verilog
    +always_ff @(posedge clk) if (valid) y <= x;
    +```
    +
    +Logic synthesis could produce from this a gated clock that pulses only when the `valid` signal is asserted. This gated clock would clock the flip-flop that updates `y`. Again, this implicit clock gating will be addressed later, so you can ignore such implicit clock gating for now.
    +
    +Explicit clock gating, on the other hand, should be identified and reported as an issue. A clock gating module or macro might be used to generate the gated clock signal. Or the gating logic itself might be explicit. Such logic might use a clock enable signal that would be ANDed with the global clock signal. Report any such code in the \"issues\" response field, and add \"TODO: LLM: ...\" comments to identify such code.
    +
    +Divided clocks are also problematic. They can be generated from a global clock by counting clock pulses. They might be implemented as a special case of clock gating by enabling a pulse once every n cycles. This would produce a divided clock with an imbalanced duty cycle, where, for example, the high duration of the clock pulse is the same as the high duration of the global clock, but the low duration is extended. Alternatively, a half-frequency clock with a balanced duty cycle might be generated by toggling a signal on every rising edge of the global clock. Divided clocks might also be generated through the use of module or macro instantiation.
    +
    +Clock signals can also be identified based on their names ('clock', 'clk', etc.), and by code comments. Any input signals beyond the global clock input that also appear to be clock signals should be reported.
    +
    +Clock signals can also be identified based on their usage. A clock signal will be used in a `posedge` or `negedge` condition of an `always @` or `always_ff`. Any edge-triggered use of a signal other than the global clock can be reported, however, it is sufficient to report the generation of or the input of such a clock. If the generation or input of the clock is reported, it is not necessary to report each use.
    +
    +You might find the use of multiple independent clocks that do not share a common global clock. Each clock might be an independent input to the module or might be generated by a phase-locked loop (PLL)--the circuit typically used to generate clocks. Generally, though different clocks would be in separate clock domains and different modules. You might see a module that is specifically providing clock crossing logic that has multiple clocks. Such modules are not good candidates for conversion to TL-Verilog.
    +
    +In the \"notes\" field of your response, report on the global clock signal, either which signal it is, that there isn't one, or that it is not clear which signal is the global clock. Again, include an extra output field, \"clock\", whose value is the name of the clock input signal. If there is no input clock signal, provide a value \"NONE\" for \"clock\".
    +
    +In the \"issues\" field of the response, list all other potential explicit input and internal clock signals (if any) with a brief description for each of what type of clock it is (or might be) and how it is used. Also, updated the code with \"TODO: LLM: ...\" comments to identify these issues in the code."
  }, {
    "id": 3,
    "desc": "Clock signal",
    "unless": {"clock": ["NONE", "clk"]},
    "needs": ["clock"],
    "consumes": ["clock"],
    "background": "TL-Verilog has a requirement that, if there is a clock signal, it is named `clk`.",
    "prompt": "The global clock signal name is reported below in the extra input field \"clock\". Create a `clk` signal at the beginning of the module. For example, if the input clock name is 'input_clk', add the line `logic clk = input_clock;` at the beginning of the module body and replace `input_clock` (in this example) with `clk` throughout the code.",
    "TODO": "Add some automation to detect code that uses `negedge` and not `posedge` and invert the clock in this case."
  }, {
    "id": 4,
    "desc": "Reset issues",
    "must_produce": ["reset", "reset_assertion"],
    "background":
    "Reset methodology varies across designs. Most designs will use an external global (\"cold\") reset signal to initialize machine state to known reset values. This reset will be propagated throughout the design, beginning as an asynchronous condition, and possibly being synchronized with the clock at some point in its distribution. Synchronous reset signals may be delayed through D-flip-flops before reaching the states they control.
    +
    +TL-Verilog constructs are for synchronous logic only. Designers often like to drive asynchronous reset signals directly into flip-flops, which would not be possible in TL-Verilog. Use of asynchronous resets can be recognized as a reset signal used as a `posedge`/`negedge` condition in an `always @` or `always_ff` block. It may also be used in an `if` condition of a non-blocking assignment.
    +
    +Often Verilog developers prefer to use inverted (aka negatively-asserted) reset signals (that are low (zero) during reset, and high (one) during normal operation), and this is fine, though FEV needs to be aware of the assertion level. Negatively-asserted reset signals might have names like `nrst`, `reset_n`, `resetb`, etc. (where 'n' stands for \"not\" and 'b' stands for \"bar\").
    +
    +Some circuits may have lesser reset signals that might reset a subset of the states in the overall circuit. These might be termed \"soft reset\", \"logic reset\", \"local reset\", etc. These should be synchronous",
    "prompt":
    "Unless it is purely combinational, our current module should have a primary reset input signal and may have other reset signals. All non-clock inputs should be synchronous. This may not be obvious from the interface definition. A name like `arst` might indicate an asynchronous reset, or code comments might indicate intent. The use of the signal as edge-triggering may also indicate an asynchronous nature. Flip-flop module names might also suggest the use of an asynchronous reset. If it appears an asynchronous input is used, report an \"issue\", and add a \"TODO: LLM: ...\" comment.
    +
    +Include two extra input fields in the response. The first will be called \"reset\" and its value will be the name of the reset signal. The second will be called \"reset_assertion\". This field indicates the assertion level of the reset signal, and it must have a value of \"high\" or \"low\". If the circuit is purely combinational and contains no reset input signals, return \"reset\" and \"reset_assertion\" field values of \"NONE\". If it is not clear which is the primary reset signal, return \"reset\" and \"reset_assertion\" field values of \"UNKNOWN\".
    +
    +Reset signals can be identified by their names (e.g. reset, rst, reset_n, resetb, nrst, etc.) and by their usage. Aside from possible comment additions/changes, there is no need to modify the Verilog code. Use \"issues\" to comment briefly on additional reset signals, describing in at most one sentence how broadly they are used in the module. Also comment and report issues for any asynchronous use of lesser reset signals."
  }, {
    "id": 5,
    "desc": "Proper reset signal",
    "if": {"reset_assertion": "low"},
    "needs": ["reset", "reset_assertion"],
    "consumes": ["reset", "reset_assertion"],
    "prompt":
    "The primary reset input signal (identified in the extra input field, \"reset\", listed below) is negatively-asserted (as determined earlier and reported in the extra input field, \"reset_assertion\", also listed below). Create a signal called `reset`, generated by inverting the primary reset input signal.
    +
    +This new signal should be used in the module in place of the primary reset input signal. Update the code to use this new `reset` signal, inverting the polarity of its use, in all cases, to preserve the original behavior."
  }, {
    "id": 6,
    "desc": "Separate declarations",
    "prompt":
    "In SystemVerilog, 'logic' and 'wire' signal declarations may be followed by an '=' and an assignment. For any statements that combine the declaration and assignment, separate these into two statements with the declaration on its own line. For example:
    +
    +```verilog
    +logic y = a & b;
    +```
    +
    +should be transformed to:
    +
    +```verilog
    +logic y;
    +y = a & b;
    +```
    +
    +Since the module interface declares output signals, no changes are required for module output assignments."
  }, {
    "id": 7,
    "desc": "Non-synthesizable, analog, and tri-state code",
    "background":
    "Our convesion process does convert non-synthesizable logic, analog modeling, and multi-driven buses (that use tri-state logic).
    +
    +Starting with non-synthesizable logic, in SystemVerilog, certain constructs are intended primarily for simulation purposes and are not synthesizable, meaning they can't be directly translated into hardware components during the synthesis process. Here's a summary of some common non-synthesizable constructs in SystemVerilog:
    +
    +Initial Blocks: Used primarily in testbenches, initial blocks execute only once at the beginning of simulation. These are used for setting up simulation parameters or initializing variables and are not suitable for hardware synthesis which requires continuously operating circuits.
    +
    +Always Blocks with Delay: Constructs like always #10 ... use simulation delays (#) to control timing, which can't be directly implemented in hardware. Delays are purely for simulation to mimic real-time behavior and are ignored in synthesis.
    +
    +Procedural Timing Controls: Timing control statements such as #, wait, and @ (event control) are used to manage simulation time and event ordering. These constructs do not have a direct hardware counterpart as hardware operation is continuous and not event-based.
    +
    +Simulation-Specific System Tasks and Functions: Functions like $display, $stop, and $monitor are used for debugging and monitoring during simulation. These constructs provide output to the console or control simulation flow but do not translate to any hardware logic.
    +
    +Fork-Join Constructs: The fork ... join construct allows multiple procedural blocks to execute concurrently in simulation, which is useful for describing parallel operations in test environments. However, the actual implementation of parallelism in hardware needs to be explicitly defined using synthesizable constructs.
    +
    +Non-Synthesizable Data Types: Certain data types, like real and string, are used for modeling and simulation purposes only. For instance, floating-point types (real, realtime) are typically used in algorithmic modeling but require explicit hardware implementation through fixed-point arithmetic or dedicated floating-point units for synthesis.
    +
    +Certain Conditional Statements: Constructs like assert and assume are used in formal verification to check properties and assumptions within the design during simulation. These are not synthesized into hardware but are crucial for ensuring design correctness in pre-synthesis simulation.
    +
    +Dynamic Memory Allocation: Dynamic constructs such as dynamic arrays, queues, and associative arrays are primarily used in testbenches for flexible data storage. These are typically not synthesizable as hardware requires fixed memory allocation.
    +
    +
    +Analog modeling is another area that is not supported by our conversion process. Analog modeling is used to describe continuous-time signals and behavior, which is fundamentally different from the discrete-time, digital logic that is synthesized into hardware. Analog constructs like continuous assignments, real numbers (`wreal`), and `analog` blocks are not supported by hardware synthesis tools and are not part of the digital logic design flow.
    +
    +
    +Tri-state logic is a type of logic that allows a signal to assume one of three states: logic 0, logic 1, or high impedance (Z-state). Tri-state logic is commonly used in bus systems to allow multiple devices to share a common bus. However, tri-state logic is not directly synthesizable into hardware and can lead to issues like bus contention and undefined logic levels. Synthesizable hardware designs typically use multiplexers or other techniques to avoid tri-state logic.",
    "prompt":
    "TL-Verilog and FEV are tools for working with digital, sequential logic. They are not intended for working with non-synthesizable verification (test bench) modeling. They are also not meant for analog logic and tri-state (Z-state) buses. Analyze the Verilog code for any use of non-synthesizable, analog, and/or tri-state logic. If any of these are found, add \"TODO: LLM: ...\" comments to the code to identify these issues, and report them in the \"issues\" field of the response. There is no need to make any code changes other than comments. If no non-synthesizable, analog, or tri-state code is found, do not make code/comment changes, and do not report issues."
  }]
}, { 
  "desc": "Logic Quality and Design Analysis",
  "prompt": "Comprehensively analyze the Verilog code for potential issues affecting synthesis, simulation determinism, and TL-Verilog conversion compatibility. This includes detecting non-deterministic behavior, partial signal assignments, implied latches, incompatible sequential elements, and design quality issues.\n\n**Non-Deterministic Behavior Detection:**\nIdentify and report code that can lead to non-deterministic behavior:\n- Inconsistent use of blocking (=) and non-blocking (<=) assignments\n- Use of initial blocks for signal initialization\n- Use of # delays in combinational logic\n- Consumption of don't-care values without proper handling\n- Multiple drivers for the same signal\n- Incomplete sensitivity lists in always blocks\n- Implicit nets (undeclared signals)\n- Indeterminate loop bounds\n- Case statements without default cases\n\nAdd \"TODO: LLM: ...\" comments with suggested corrections where possible.\n\n**Partial Signal Assignment Elimination:**\nTL-Verilog only supports assignment statements that assign all bits of a signal. Eliminate situations where the left-hand side specifies explicit bit ranges like \"foo[FOO_WIDTH-1:3] = ...\".\n\nStrategies for refactoring:\n1. **Concatenation for contiguous ranges:**\n```verilog\n// Original\ny[3:0] = a;\ny[7:4] = b;\n// Refactored\ny = {b, a};\n```\n2. **Intermediate signals for complex cases:**\n```verilog\nlogic [3:0] y_low;   // Intermediate signal\nlogic [7:4] y_high;  // Intermediate signal\nassign y_low = a;\nassign y_high = b;\nassign y = {y_high, y_low};\n```\n\n**Implied Latch Detection:**\nImplied latches occur when combinational logic doesn't specify outputs for all input conditions. Verify that all signals assigned combinationally are fully specified. Analyze assignments sequentially within always blocks - once a signal is fully specified, subsequent assignments are immaterial.\n\n**Sequential Element Compatibility:**\nEnsure the design contains only rising-edge-triggered D-flip-flops. Report any other sequential elements (T flip-flops, JK flip-flops, falling-edge triggered elements, or latches) in the \"issues\" field.\n\n**Latch Detection:**\nIdentify level-sensitive latches which are not supported by the conversion flow. Typical latch patterns:\n```verilog\nalways @(clk or d) begin\n    if (clk == 1'b1)\n        q = d;  // Level-sensitive behavior\nend\n```\n\nAdd \"TODO: LLM: ...\" comments for all identified issues without making corrections at this stage.",
  "substeps": [{
    "id": 8,
    "desc": "Identify non-deterministic behavior",
    "background": 
    "Some constructs in Verilog can lead to non-deterministic behavior or inconsistent behavior on different simulation tools. The following are some examples of non-deterministic code:
    +
    +- Inconsistent use of blocking and non-blocking assignments. Blocking assignments should be used for combinational logic, and non-blocking assignments should be used for sequential logic triggered by a clock. If blocking and non-blocking assignments are not used properly, race conditions can occur.
    +- Use of `initial` blocks to initialize signals. This can lead to non-deterministic behavior because the order of execution of `initial` blocks is not guaranteed.
    +- Use of `#` delays in combinational logic. This can lead to non-deterministic behavior because the order of execution of the logic is not guaranteed.
    +- Use of `initial` blocks.
    +- Consumption of dont-care values. Use of dont-cares can be good practice, but care must be taken to ensure that they do not affect behavior. Dont-care propagation is not consistent across simulation tools.
    +- Consumption of signals that will not settle to a known value during reset.
    +- Multiple drivers for a signal.
    +- Use of `#` delays in combinational logic.
    +- Incomplete sensitivity lists in `always` blocks.
    +- Implicit nets (in other words, signals that aren't declared).
    +- Indeterminate loop bounds (those that cannot be statically determined).
    +- Case statements without a `default` case. This can lead to non-deterministic behavior if the case statement is not fully enumerated.",
    "prompt": "Identify non-deterministic code and summarize issues in the \"issues\" field of the response. Add \"TODO: LLM: ...\" comments to non-deterministic code to identify these issues and to provide suggested corrections where possible. Do not make any changes to the code at this time other than adding comments."
  }, {
    "id": 9,
    "desc": "Avoid partial signal assignments",
    "prompt":
    "TL-Verilog currently only supports assignment statements that assign all bits of a signal. Try to eliminate all situations where an assignment statement's assigned signal (on the left-hand side of the \"=\") specifies an explicit bit range, such as \"foo[FOO_WIDTH-1:3] = ...;\". Bit ranges used on the right-hand side of an assignment statement are not a problem.
    +
    +In the simplest case, the specified bit range might refer to the entire signal, in which case, it can be removed. If different bit ranges of a signal are assigned by different statements, attempt to refactor the code. A few strategies are possible:
    +
    +Multiple assignments can be turned into one by using concatenation. This requires the assigned bit ranges to be contiguous. For example, in this code:
    +
    +```verilog
    +logic y[7:0];
    +assign y[3:0] = a;
    +assign y[7:4] = b;
    +```
    +
    +`y[7:4]` and `y[3:0]` are contiguous and comprise the complete signal `y`. We combine their assignments by concatenating their left-hand-sides as:
    +
    +```verilog
    +logic y[7:0];
    +assign y = {b, a};
    +```
    +
    +Another approach is to define intermediate signals for the partial bit ranges. In the example above, the original code, separately assigning `y[3:0]` and `y[7:4]` could alternatively have been refactored as:
    +
    +```verilog
    +logic [7:0] y;
    +logic [3:0] y_low;   // LLM: Temporary: Intermediate signal for partial assignment.
    +logic [7:4] y_high;  // LLM: Temporary: Intermediate signal for partial assignment.
    +assign y_low = a;
    +assign y_high = b;
    +assign y = {y_high, y_low};  // LLM: Temporary: Combined the partial assignments.
    +```
    +
    +This strategy preserves the structure of the various assignments of the signal. It can be the best choice for signals whose various bit ranges are assigned under different conditions within an always block.
    +
    +Look for assignment statements that assign a partial bit range of a signal and refactor the code to eliminate these partial assignments. If you find any partial assignments that are difficult to refactor, report them in the \"issues\" field of the response and add \"TODO: LLM: ...\" comments to identify these issues in the code."
  }, {
    "id": 10,
    "desc": "No implied latches",
    "background":
    "In digital design using Verilog, an \"implied latch\" refers to a storage element that is created due to incomplete specification of conditions in combinational logic coding. This happens when the Verilog code does not explicitly define the output for all input conditions, often within an `always` block.
    +
    +Implied latches are typically formed in two scenarios:
    +
    +Missing Else Condition: This is common in conditional statements (`if`, `case`) where not all possible conditions are accounted for. For example, in an `if` statement without a corresponding `else` part, if the `if` condition is not met, the output retains its previous state, implying a latch to store that state.
    +
    +Incomplete Case Statements: Similarly, in a `case` statement, if not all possible cases are covered and there is no default condition, a latch will be implied to hold the output state until a covered case occurs.
    +
    +Example of Implied Latches:
    +
    +```verilog
    +always @(a or b)
    +begin
    +    if (a == 1'b1)
    +        y = b;
    +    // No else part; what happens when a is not 1?
    +end
    +```
    +
    +In this example, when `a` is not 1, the value of `y` is not defined, which leads to the creation of an implied latch. To maintain its last state, hardware for a latch will be synthesized.
    +
    +It is important to understand that this implied-latch case only relates to combinational always blocks, such as `always_comb` blocks and `always` blocks that are not edge-sensitive. The term \"implied latch\" does not apply to similar scenarios for non-blocking assignments in edge-triggered blocks. Though latches could be implied by non-blocking assignments, they are not considered implied latches because their are other ways to treat these cases that do not involve latches.",
    "prompt":
    "Make sure there are no implied latches in the design. Verify that all signals that are assigned combinationally (by blocking `=` assignments) are fully specified. In other words, there must be no condition under which the signal is unassigned.
    +
    +This analysis can be non-trivial. Since semantics are sequential within an always block, the best strategy is to analyze the assignments of the signal sequentially. Once the signal is determined to be fully specified, subsequent assignments are immaterial. For `if` statements and nested `if` statements, if every `if` has a corresponding `else`, and each case assigns the signal in question, that signal is fully specified......
    +
    +Any issues will be addressed by the user, so make no changes to the code at this time other than adding comments.
    +
    +Identify any issues in the \"issues\" field of the response, and add \"TODO: LLM: ...\" comments to capture these issues in the code without making corrections."
  }, {
    "id": 11,
    "desc": "Rising edge D-type flip-flops only",
    "background":
    "It is most typical for flip-flop-based sequential logic to consistently use flip-flops that are triggered on the rising edge of the clock.
    +
    +In sequential logic design, D flip-flops are the most common type of flip-flop used. They are edge-triggered, meaning that the output of the flip-flop changes only on the rising or falling edge of the clock signal. (In our case, they should be triggered by the rising edge.) For D-type flip-flops, this clock edge results in the input value being driven at the output. Other types of flip-flops, such as T flip-flops and JK flip-flops, are less common in modern designs. They incorporate a logic function in addition to their sequential behavior.",
    "prompt":
    "If the code contains any sequentials other than rising-edge-triggered D-flip-flops, report issues in the \"issues\" field of the response and add \"TODO: LLM: ...\" comments to capture these issues in the code. Do not make any changes to the code other than adding these comments (if needed)."
  }, {
    "id": 12,
    "desc": "Avoid latches",
    "prompt":
    "Our conversion flow does not support designs containing latches. At this point, if there are any latches in our design to address, they should be level-sensitive latches, allowing values to propagate during one of the phases of the clock. A typical coding pattern for such a latch might be:
    +
    +```verilog
    +always @(clk or d) begin
    +if (clk == 1'b1) begin
    +    q = d;  // Output follows input while clock is high
    +end
    +// When clk is low, q holds its value
    +end
    +```
    +
    +If there are latches in the design, identify them in the \"issues\" field of the response and add \"TODO: LLM: ...\" comments to capture these issues in the code."
  }]
}, { 
  "desc": "Conditional Logic Transformation to Ternary Expressions",
  "prompt": "Transform all conditional logic structures (if/else statements and case statements) into TL-Verilog friendly ternary expressions. This systematic transformation improves code readability and prepares for TL-Verilog conversion.\n\n**If/Else to Ternary Transformation:**\nTransform innermost if/else statements that assign signals in all cases into ternary expressions:\n```verilog\n// Original\nif (cond)\n    y = b;\nelse\n    y = c;\n// Transformed\ny = cond ? b : c;  // LLM: Temporary: Transformed from if/else chain.\n```\n\nFor complex nested structures, work incrementally:\n```verilog\n// Original complex case\nif (valid) begin\n    if (cond1)\n        y = b;\n    else if (cond2)\n        y = c;\n    else begin\n        y = d;\n        z = e;\n    end\nelse\n    y = f;\nend\n\n// First transformation (inner if/else)\ny = valid ? (cond1 ? b : cond2 ? c : d) : f;\nif (valid && !cond1 && !cond2)\n    z = e;\n```\n\n**Conditional Assignment Merging:**\nCombine unconditional assignments followed by conditional assignments using ternary expressions:\n```verilog\n// Original\nalways_comb begin\n    y = 1'b0;      // first assignment\n    if (b)\n        y = d;     // conditional assignment  \n    if (c)\n        y = e;     // another conditional\nend\n\n// Transformed\nalways_comb begin\n    y = c ? e :    // Latest condition first\n        b ? d :    // Previous condition\n            1'b0;  // Original assignment\nend\n```\n\n**Case Statement to Ternary Transformation:**\nTransform case statements into ternary expressions:\n```verilog\n// Original\ncase (a)\n    2'b00: y = b;\n    2'b01: y = c;\n    default: y = d;\nendcase\n\n// Transformed\ny = (a == 2'b00) ? b : (a == 2'b01) ? c : d;\n```\n\n**Existing Ternary Expression Handling:**\nMark existing ternary expressions to avoid false progress indicators:\n```verilog\ny = cond ? a : b;  // LLM: Temporary: Nothing changed here.\n```\n\nWork incrementally - transform at least one structure if available, but don't attempt everything at once. If significant conditional logic remains, respond with \"incomplete\": true.",
  "substeps": [{
    "id": 13,
    "desc": "Replace if/else with ternary expressions",
    "prompt":
    "For signals assigned in all cases of an inner-most `if`/`else` statement or chain. Transform the signal's assignments into a ternary expression. For example, transform:
    +
    +```verilog
    +if (cond)
    +    y = b;
    +else
    +    y = c;
    +```
    +
    +into:
    +
    +```verilog
    +// LLM: Temporary: Transformed from if/else chain.
    +y = cond ? b : c;
    +```
    +
    +Let's look at a more interesting example.
    +
    +```verilog
    +...
    +    if (valid) begin
    +        if (cond1)
    +            y = b;
    +        else if (cond2)
    +            y = c;
    +        else begin
    +            y = d;
    +            z = e;
    +        end
    +    else
    +        y = f;
    +    end
    +...
    +```
    +
    +might be transformed into:
    +
    +```verilog
    +...
    +    // LLM: Task: This \"if\" block needs further consideration.
    +    if (valid) begin
    +        // LLM: Temporary: Transformed from if/else chain.
    +        y = cond1 ? b :
    +            cond2 ? c :
    +                    d;
    +
    +        if (!cond1 && !cond2)    // LLM: Temporary: Removed the original `if` and `if else` cases and updated the condition accordingly.
    +            z = e;  // LLM: Temporary: Cannot be transformed because not all conditions result in an assignment.
    +    else
    +        y = f;
    +    end
    +...
    +```
    +
    +Notice a few things in the above example:
    +  - The \"z\" signal is not transformed because not all conditions result in an assignment. With the \"y\" signal removed, the `if`/`else` chain was simplified for the remaining \"z\" signal.
    +  - Having reduced the inner expression for \"y\", the outer `if`/`else` can then be turned into an extension of the ternary expression for \"y\". This transformation is tagged as a subsequent task. rather than tackling too much at once.
    +
    +A subsequent transformation of the above example might result in this further-updated verilog:
    +
    +```verilog
    +...
    +    // LLM: Temporary: Extended with `valid` case from `if` condition.
    +    y = valid ? cond1 ? b :
    +                cond2 ? c :
    +                        d :
    +                f;
    +
    +    if (valid && !cond1 && !cond2)    // LLM: Temporary: Incorporated `valid` from `if` expression.
    +        z = e;
    +...
    +```
    +
    +This would complete the refactoring of `y`, and there is nothing more to do for `z` either.
    +
    +As you go through the Verilog code, you may find that it already contains ternary expressions. Since these look like refactoring progress, but are not, mark them with comments like \"// LLM: Temporary: Nothing changed here.\" Otherwise you might mistakenly believe you have made forward progress when you have not. Since these will be removed from your response they will have no other impact and will cause no harm."
  }, {
    "id": 14,
    "desc": "Merge conditional assignments using ternary expressions",
    "prompt":
    "Where a signal is assigned within an always block, then assigned conditionally (under an `if` or case statement), combine the conditional assignment with the unconditional assignment using a ternary expression. These assignments could be nested under an outer condition--that doesn't matter. The conditional assignment's condition becomes the condition of the added ternary expression added to the first assignment. If these are followed by another conditional assignment, this transformation can be applied again, adding a new first ternary expression, resulting in a new ternary chain. For example:
    +
    +```verilog
    +always_comb begin
    +    if (a)
    +    begin
    +        y = 1'b0;   // first assignment
    +        if (b)
    +            y = d;  // conditional assignment
    +        if (c)
    +            y = e;  // another conditional assignment
    +    end
    +end
    +```
    +
    +can be transformed to:
    +
    +```verilog
    +always_comb begin
    +    if (a)
    +    begin
    +        y = c ? e :    // another conditional assignment
    +            b ? d :    // conditional assignment
    +                1'b0;  // first assignment
    +    end
    +end
    +```
    +
    +As always, don't tackle too much at once. Do at least one transformation if there is one to be done, but don't feel compelled to do more than a few. If any assignments remain to be combined, respond with an \"incomplete\" value of \"true\"."
  }, {
    "id": 15,
    "desc": "Use ternary expressions instead of case",
    "prompt":
    "Transform `case` statements that assign a value to a signal into ternary expressions. For example, transform:
    +
    +```verilog
    +case (a)
    +    2'b00: y = b;
    +    2'b01: y = c;
    +    default: y = d;
    +endcase
    +```
    +
    +into:
    +
    +```verilog
    +y = (a == 2'b00) ? b : (a == 2'b01) ? c : d;
    +```"
  }, {
    "id": 16,
    "desc": "Use ternary expressions instead of if/else",
    "prompt":
    "Transform `if`/`else` statements that assign a value to a signal into ternary expressions. For example, transform:
    +
    +```verilog
    +if (a)
    +    y = b;
    +else
    +    y = c;
    +```
    +
    +into:
    +
    +```verilog
    +y = a ? b : c;
    +```"
  }]
}, {
  "desc": "Sequential Logic Architecture Refactoring",
  "prompt": "Transform sequential logic to be fully TL-Verilog compatible by converting to SystemVerilog always blocks, separating combinational and sequential logic, creating individual flip-flops, and ensuring proper incomplete conditional handling.\n\n**Incomplete Conditional Handling:**\nFor clock-edge-triggered always blocks with incomplete assignments (not assigned under all input conditions), provide explicit recirculation through multiplexer and D-flip-flop:\n```verilog\n// Original incomplete\nalways_ff @(posedge clk) begin\n    if (reset)\n        y <= 1'b0;\n    else if (a)\n        y <= b;\n    // Missing else - incomplete!\nend\n\n// Fixed with explicit recirculation\nalways_ff @(posedge clk) begin\n    if (reset)\n        y <= 1'b0;\n    else if (a)\n        y <= b;\n    else\n        y <= y;  // Explicit recirculation\nend\n```\n\nSimilarly for case statements:\n```verilog\n// Add default case for incomplete case statements\ncase (sel)\n    2'b00: y <= a;\n    2'b01: y <= b;\n    default: y <= y;  // Explicit recirculation\nendcase\n```\n\n**SystemVerilog Always Block Conversion:**\nReplace Verilog always blocks with SystemVerilog equivalents:\n- `always @(posedge clk)` → `always_ff @(posedge clk)` (should use <= assignments)\n- `always @*` or `always @(sensitivity_list)` → `always_comb` (should use = assignments)\n\n**Combinational/Sequential Logic Separation:**\nSeparate combinational logic from always_ff blocks into always_comb blocks:\n```verilog\n// Original mixed logic\nalways_ff @(posedge clk) begin\n    if (reset)\n        y <= 1'b0;\n    else if (a)\n        y <= b;\n    else\n        y <= y;\nend\n\n// Separated into combinational and sequential\nlogic NEXT_y;\n\nalways_comb begin\n    if (reset)\n        NEXT_y = 1'b0;\n    else if (a)\n        NEXT_y = b;\n    else\n        NEXT_y = y;\nend\n\nalways_ff @(posedge clk)\n    y <= NEXT_y;\n```\n\n**Signal Type Standardization:**\nReplace all `reg` and `wire` declarations with `logic` for SystemVerilog compatibility.\n\n**Individual Flip-Flop Creation:**\nBreak always_ff blocks assigning multiple signals into separate blocks, one per signal:\n```verilog\n// Original multi-signal block\nalways_ff @(posedge clk) begin\n    y <= NEXT_y;\n    z <= NEXT_z;\nend\n\n// Individual flip-flops\nalways_ff @(posedge clk) y <= NEXT_y;\nalways_ff @(posedge clk) z <= NEXT_z;\n```",
  "substeps": [{
    "id": 17,
    "desc": "No incomplete conditionals",
    "background":
    "Signals should be assigned by one and only one statement or block.
    +
    +In a combinational statement or block (sensitive to logic signals, not to a clock edge), each signal should be assigned for all possible inputs to avoid implied latches. At this point, our Verilog code should be free of implied latches.
    +
    +In `always` blocks that are triggered by a clock, such as `always @(posedge clk)` and `always_ff @(posedge clk)`, input combinations that result in no assignment, imply that the value must be held. A logic synthesis tool could implement this is various ways. The most direct interpretation might imply a latch after the logic expression that prevents the result of the expression from propagating through the latch in cases where no assignment would be made. Thus the enable input for the latch would be this no-assignment condition. This would be an awkward use of a latch in the context of otherwise flip-flop-based logic. Logic synthesis might instead derive a circuit with an explicit recirculation path to preserve the unchanged value. In this case, the edge-triggered always block results in a D-flip-flop that is driven by the logic within the always block. The implied recirculation path would feed the flop output through a multiplexer back into the flop. The multiplexer would select this recirculation path in cases where no assignment is made. Alternatively, logic synthesis might infer clock gating to retain the value by gating off the clock pulse when no update is to be made to the always block's output value.",
    "prompt":
    "For signals assigned by a clock-edge-triggered always block whose assignment is incomplete (in other words, the signal is not assigned under all possible input conditions), update the Verilog code to provide explicit recirculation of the value through a multiplexer and D-flip-flop. For example:
    +
    +```verilog
    +always_ff @(posedge clk)
    +begin
    +    if (reset)
    +        y <= 1'b0;
    +    else if (a)
    +        y <= b;
    +end
    +```
    +
    +should be updated to:
    +
    +```verilog
    +always_ff @(posedge clk)
    +begin
    +    if (reset)
    +        y <= 1'b0;
    +    else if (a)
    +        y <= b;
    +    else
    +        y <= y; // Recirculate the value explicitly
    +end
    +```
    +
    +Similary, for a `case` statement:
    +
    +```verilog
    +always_ff @(posedge clk)
    +begin
    +    case (sel)
    +        2'b00: y <= a;
    +        2'b01: y <= b;
    +    endcase
    +end
    +```
    +
    +should be updated to:
    +
    +```verilog
    +always_ff @(posedge clk)
    +begin
    +    case (sel)
    +        2'b00: y <= a;
    +        2'b01: y <= b;
    +        default: y <= y; // Recirculate the value explicitly
    +    endcase
    +end
    +```
    +
    +If there are no incomplete assignments, do not make any changes to the code. And remember, even though block quotes are provided here to delimit Verilog code snippets, the \"verilog\" field of your response should provide the literal Verilog code without block quotes."
  }, {
    "id": 18,
    "desc": "Use SystemVerilog always blocks",
    "prompt":
    "Get rid of Verilog `always` blocks and replace them with SystemVerilog `always_ff` and `always_comb` blocks. For example, `always @(posedge clk)` should be replaced with `always_ff @(posedge clk)`. Such blocks should already use non-blocking (`=>`) assignments, not blocking ones, and no internal changes should be needed within the blocks. `always @*` or `always` blocks with non-edge-triggered sensitivity lists should be replaced by `always_comb`. These should already use blocking (`=`) assignments, not non-blocking ones, and no internal changes should be needed within the blocks. Update the code to use these SystemVerilog always blocks. Only modify pre-existing `always` blocks. In particular, do not modify `assign` statements."
  }, {
    "id": 19,
    "desc": "Separate combinational and sequential logic blocks",
    "prompt":
    "Let's avoid having combinational logic in `always_ff` blocks. Modify `always_ff` blocks as and if necessary to separate combinational and sequential logic (D flip-flops) into separate always blocks. Combinational logic should be in `always_comb` blocks, and flip-flops should be in `always_ff` blocks.
    +
    +For example:
    +
    +```verilog
    +always_ff @(posedge clk)
    +begin
    +    if (reset)
    +        y <= 1'b0;
    +    else if (a)
    +        y <= b;
    +    else
    +        y <= y; // Recirculate the value
    +end
    +```
    +
    +should become:
    +
    +```verilog
    +logic NEXT_y;
    +
    +always_comb
    +begin
    +    if (reset)
    +        NEXT_y = 1'b0;
    +    else if (a)
    +        NEXT_y = b;
    +    else
    +        NEXT_y = y; // Recirculate the value
    +end
    +
    +always_ff @(posedge clk)
    +begin
    +    y <= NEXT_y;
    +end
    +```
    +
    +Generally, to transform an `always_ff` block that includes combinational logic:
    +
    +- Declare new signals that represent the values that are flopped. Use the prefix `NEXT_` for these
    +- Change `always_ff` blocks to `always_comb` and non-blocking assignments to blocking ones. These blocking assignments should assign the `NEXT_` versions of the signals.
    +- Add `always_ff` blocks to flop the `NEXT_` signals to the original signals."
  }, {
    "id": 20,
    "desc": "Use 'logic' for all signals",
    "background":
    "SystemVerilog introduced the `logic` data type to replace the `reg` and `wire` data types in Verilog. The `reg` and `wire` data types are still supported in SystemVerilog for backward compatibility, but it is recommended to use `logic` for all signal declarations.",
    "prompt":
    "Replace all `reg` and `wire` declarations with `logic`."
  }, {
    "id": 21,
    "desc": "Individual flip-flops",
    "prompt":
    "For `always_ff` blocks that assign multiple signals, break them into separate `always_ff` blocks, one for each flopped signal. Each block may be written on a single line without `begin`/`end`, such as: `always_ff @(posedge clk) y <= NEXT_y;`."
  }]
}, {
  "desc": "Combinational Logic Optimization and Restructuring",
  "prompt": "Optimize and restructure combinational logic by breaking up large always_comb blocks, converting them to assign statements, extracting common subexpressions, and preparing for TL-Verilog's assignment-based paradigm.\n\n**Always_comb Block Decomposition:**\nTL-Verilog favors individual, independent assignment statements over large combinational always_comb blocks. Break up large blocks incrementally, being careful not to separate portions that assign the same signal.\n\n**Per-Signal Block Creation:**\nBreak the first multi-signal always_comb block into separate blocks, one per assigned signal:\n```verilog\n// Original multi-signal block\nalways_comb begin\n    if (type == 2'b00) begin\n        y = a;\n        z = b;\n    else begin\n        y = c;\n        if (big)\n            z = d;\n        else\n            z = e;\n    end\nend\n\n// Separated per signal\nalways_comb begin\n    if (type == 2'b00)\n        y = a;\n    else\n        y = c;\nend\n\nalways_comb begin\n    if (type == 2'b00)\n        z = b;\n    else begin\n        if (big)\n            z = d;\n        else\n            z = e;\n    end\nend\n```\n\n**Strategy for Signal Separation:**\n1. Identify the first signal to separate\n2. Walk through the block code and include parts affecting that signal\n3. Repeat for remaining signals\n4. Handle comments carefully - replicate if uncertain about association\n\nFor overly disruptive cases, add comment: \"LLM: This block should be translated to TL-Verilog using a TL-Verilog \\always_comb block\"\n\n**Unnecessary Begin/End Removal:**\nRemove begin/end around single statements:\n```verilog\n// Original\nif (cond) begin\n    y = a;\nend\n\n// Simplified\nif (cond)\n    y = a;\n```\n\n**Always_comb to Assign Conversion:**\nTransform single-signal always_comb blocks into assign statements:\n```verilog\n// Original\nalways_comb begin\n    y = a & b;\nend\n\n// Converted\nassign y = a & b;\n```\n\n**Common Subexpression Extraction:**\nIdentify repeated subexpressions and extract them to intermediate signals when it simplifies code:\n```verilog\n// Original with repeated subexpression\nassign foo = (valid && type == 2'b00) ? a : c;\nassign bar = (valid && type == 2'b00) ? b : (big ? d : e);\n\n// Extracted common subexpression\nlogic valid_type0 = valid && type == 2'b00;\nassign foo = valid_type0 ? a : c;\nassign bar = valid_type0 ? b : (big ? d : e);\n```\n\nProcess incrementally - handle one subexpression per step and indicate incompleteness if more remain.",
  "substeps": [{
    "id": 22,
    "desc": "Short always blocks",
    "prompt":
    "TL-Verilog favors individual, independent assignment statements per signal over large, combinational `always_comb` blocks with sequential semantics. To work incrementally toward this, break up `always_comb` blocks into smaller blocks. Be careful not to separate portions of a block that assign the same signal.
    +
    +At this time, do not do any substantial code restructuring. Just make the easy changes.
    +
    +Be sure to preserve the comments from within the original block. Determine how these comments correspond to the code. Comments that associate with multiple of the new block can be moved outside of their `always_comb` block. Those that associate with the entirety of a new block can also be moved outside the new block. Other comments may associate with internal portions of a block and should remain internal to the new blocks."
  }, {
    "id": 23,
    "desc": "Combinational logic block per signal",
    "prompt":
    "For the first `always_comb` block in which multiple signals are assigned, break the block into multiple `always_comb` blocks, one per assigned signal. For example:
    +
    +```verilog
    +always_comb
    +begin
    +    if (type == 2'b00)
    +    begin
    +        y = a;
    +        z = b;
    +    else
    +    begin
    +        y = c;
    +        if (big)
    +            z = d;
    +        else
    +            z = e;
    +    end
    +end
    +```
    +
    +should be transformed to:
    +
    +```verilog
    +always_comb
    +begin
    +    if (valid && type == 2'b00)
    +    begin
    +        y = a;
    +    else
    +    begin
    +        y = c;
    +    end
    +end
    +
    +always_comb
    +begin
    +    if (valid && type == 2'b00)
    +    begin
    +        z = b;
    +    else
    +    begin
    +        if (big)
    +            z = d;
    +        else
    +            z = e;
    +    end
    +end
    +```
    +
    +The recommended strategy for doing this is to identify the first signal to separate out. Walk through the code of the block and include those parts of the block that affect that particular signal to form its `always_comb` block. Then, repeat this process for the remaining signals.
    +
    +Handling comments appropriately can be tricky. Some comments might be relevant to multiple signals, and the code for these signals is getting separated. In some cases it might be best to move the comment outside the the `always_comb` blocks. The comment may need some rewording in its new context. Be sure not to lose any comments, their meaning, or their association. When uncertain, replicate the comments in each new block. Add \"TODO: LLM: ...\" comments to the code to identify any such commenting issues that would benefit from human review, and report them in \"issues\".
    +
    +If breaking up a particular `always_comb` block would be overly disruptive to the code structure, leave it as is and add a comment such as \"LLM: This block should be translated to TL-Verilog using a TL-Verilog `\\always_comb` block\". If you encounter a block that already has such a comment, be sure to process the next block.
    +
    +If there are other `always_comb` blocks that assign multiple signals that you have not processed, respond with an \"incomplete\" field of \"true\""
  }, {
    "id": 24,
    "desc": "Remove unnecessary begin/end",
    "prompt":
    "Anywhere `begin`/`end` are used around a single statement, remove them."
  }, {
    "id": 25,
    "desc": "Use assign",
    "prompt":
    "Transform `always_comb` blocks that assign a single signal into `assign` statements. For example, transform:
    +
    +```verilog
    +always_comb
    +begin
    +    y = a & b;
    +end
    +```
    +
    +into:
    +
    +```verilog
    +assign y = a & b;
    +```"
  }, {
    "id": 26,
    "desc": "Common subexpressions",
    "prompt":
    "Scan the code for common subexpressions (subexpressions that are repeated multiple times in different expressions). Only if and where doing so would simplify the code, use an intermediate signal for this subexpression. Declare the intermediate signal with the correct bit width. Extract the subexpression into a separate `assign` statement, and replace all occurances with this new signal. For example:
    +
    +```verilog
    +assign foo = (valid && type == 2'b00) ? a : c;
    +assign bar = (valid && type == 2'b00) ? b : (big ? d : e);
    +```
    +
    +could be transformed to:
    +
    +```verilog
    +logic valid_type0;
    +assign valid_type0 = valid && type == 2'b00;
    +assign foo = valid_type0 ? a : c;
    +assign bar = valid_type0 ? b : (big ? d : e);
    +```
    +
    +It might be best to process no more than one subexpression (if any) and leave the rest for another agent, indicating that changes are incomplete and outlining a plan for the remaining changes of this refactoring step."
  }]
}, {
  "desc": "Code Structure and Declaration Management",
  "prompt": "Clean up the overall code structure by organizing generate blocks with proper naming, localizing declarations to appropriate scopes, combining declarations with assignments where beneficial, and elevating declarations to proper hierarchical levels.\n\n**Generate Block Naming and Syntax:**\nFor consistency, give every generate block a short, appropriate name and remove all uses of `generate`/`endgenerate` (which are optional in SystemVerilog):\n```verilog\n// Original\ngenvar i;\ngenerate\n    for (i = 0; i < 4; i = i + 1) begin: my_block\n        // ...\n    end\nendgenerate\n\n// Cleaned up\nfor (genvar i = 0; i < 4; i = i + 1) begin: my_block\n    // ...\nend\n```\n\n**Declaration Localization:**\nMake declarations as localized as possible. Signals used only within a generate block should be declared within that block. For signals used in for loops:\n\n```verilog\n// Original - array declarations outside loop\nlogic [31:0] x [3:0];\nlogic [31:0] y [3:0];\nfor (genvar i = 0; i < 4; i = i + 1) begin: my_block\n    assign x[i] = i;\n    assign y[i] = x[(i + 1) % 4];\nend\n\n// Localized - individual signals inside loop\nfor (genvar i = 0; i < 4; i = i + 1) begin: my_block\n    logic [31:0] x;\n    logic [31:0] y;\n    assign x = i;\n    assign y = my_block[(i + 1) % 4].x;  // Cross-reference through named block\nend\n```\n\n**Declaration and Assignment Combination:**\nCombine logic signal declarations with their assignments when beneficial:\n```verilog\n// Original separated\nlogic y;\nassign y = a & b;\n\n// Combined\nlogic y = a & b;\n```\n\n**Declaration Elevation:**\nReorder code to elevate all signal declarations to the top of their containing scope:\n- Module-level signals to top of module body\n- Loop/conditional block signals to top of their respective blocks\n\nThis creates a clear separation between declarations and logic, improving code readability and maintainability.\n\n**Comment Preservation:**\nCarefully preserve and appropriately relocate comments during restructuring. Comments that span multiple blocks may need to be moved outside the blocks or replicated. Add \"TODO: LLM: ...\" comments for complex commenting situations requiring human review.",
  "substeps": [{
    "id": 27,
    "desc": "Named block syntax",
    "background":
    "In Verilog, `generate` blocks can be named. For example:
    +
    +```verilog
    +genvar i;
    +generate
    +    for (i = 0; i < 4; i = i + 1) begin: my_block
    +        ...
    +    end
    +endgenerate
    +```
    +
    +The `generate`/`endgenerate` keywords are optional in SystemVerilog, so this can be:
    +
    +```verilog
    +for (genvar i = 0; i < 4; i = i + 1) begin: my_block
    +    ...
    +end
    +```",
    "prompt":
    "For consistency, give every generate block a short, appropriate name, and remove all uses of `generate`/`endgenerate`."
  }, {
    "id": 28,
    "desc": "Localize declarations",
    "prompt":
    "Make declarations as localized as possible, for example, if a signal is only used within a generate block it should be declared within that block. Signals used only within a `for` loop that are declared outside that loop must be declared with an array dimension that provides a definition per loop instance. When moved inside the loop, this array replication should be eliminated. If the logic references the signal with an index other than the loop index, the reference can be updated to explicitly reference the signal through the other named loop index. For example:
    +
    +```verilog
    +logic [31:0] x [3:0];
    +logic [31:0] y [3:0];
    +for (genvar i = 0; i < 4; i = i + 1) begin: my_block
    +    assign x[i] = i;
    +    assign y[i] = x[(i + 1) % 4];
    +end
    +```
    +
    +should be transformed to:
    +
    +```verilog
    +for (genvar i = 0; i < 4; i = i + 1) begin: my_block
    +    logic [31:0] x;
    +    logic [31:0] y;
    +    assign x = i;
    +    assign y = my_block[(i + 1) % 4].x;
    +end
    +```"
  }, {
    "id": 29,
    "desc": "Embed declarations in assignments",
    "prompt":
    "`logic` signal declarations may be followed by an assignment. Combine declarations and assignments. For example:
    +
    +```verilog
    +logic y;
    +assign y = a & b;
    +```
    +
    +becomes:
    +
    +```verilog
    +logic y = a & b;
    +```"
  }, {
    "id": 30,
    "desc": "Elevate declarations",
    "prompt":
    "Reorder the code to elevate all signal declarations to the top of the module body or to the top of the loop or conditional block containing their declaration."
  }]
}, {
  "desc": "Pipeline Analysis and Signal Staging Optimization",
  "must_produce": ["naming"],
  "may_produce": ["pipelines"],
  "prompt": "Comprehensively analyze the design for pipeline structures, determine and document signal naming conventions, optimize reset usage for pipeline-aware design, and prepare the code for pipeline-aware TL-Verilog conversion.\n\n**Signal Naming Convention Analysis:**\nAnalyze signal names looking for suffixes/prefixes indicating signal nature and staging:\n- Pipeline stage indicators (often numeric suffixes or stage mnemonics)\n- Input/output prefixes ('i_', 'o_')\n- Temporary signal indicators (like 'NEXT_' prefix used in conversion)\n- Clock edge indicators (signals that change on rising/falling edges)\n- Grouping conventions for related logic\n\nPay particular attention to staging relationships between signals. Document findings in the \"naming\" extra output field.\n\n**Data Flow Analysis:**\nAnalyze how data flows through the design:\n- Identify data paths from inputs to outputs\n- Trace signal transformations through processing stages\n- Note any backpressure or stalling mechanisms\n- Pay attention to high-level code comments describing microarchitecture\n\nAdd \"LLM: ...\" comments describing the data flow patterns discovered.\n\n**Pipeline Structure Identification:**\nIdentify pipeline structures where computations/processing span multiple clock cycles:\n- Look for data staging through multiple flip-flops\n- Identify free-flowing processing without backpressure/stalling\n- Determine meaningful names for identified pipelines\n- Establish pipeline stage numbering (first stage with logic = stage 1)\n\nAdd \"LLM: ...\" comments annotating pipeline stages. If no pipelines found, set \"pipelines\" extra output field to \"none\".\n\n**Reset Optimization:**\nAnalyze reset usage for optimization opportunities:\n- Identify signals forced to specific values during reset\n- Determine if signals would naturally assume the same values without explicit reset\n- Remove unnecessary reset assignments where the natural value matches the reset value\n\nThis reduces reset complexity while maintaining correct initialization behavior.\n\n**Pipeline Signal Naming Convention:**\nApply consistent naming for pipelined signals using the convention:\n`<name>__<PIPELINE><stage>`\n\nExamples:\n- `pc__CPU_A3` for program counter at stage 3 of CPU pipeline\n- `data__MEM_A1` for data at stage 1 of memory pipeline\n\nUse uppercase for pipeline mnemonics and 'A' (for 'at') before stage numbers.\n\n**Staged Reset Implementation:**\nFor pipelined designs, implement staged reset methodology where reset signals traverse pipelines like data:\n- Pipeline the reset signal through the same stages as data\n- Apply staged reset versions to appropriate pipeline stages\n- This creates \"reset transactions\" that flow through the pipeline\n\nSince reset is held for multiple cycles, this approach typically has no functional impact but improves timing and design consistency.\n\n**Pipeline Stage Documentation:**\nDocument pipeline stages clearly in code comments, noting:\n- Pipeline boundaries and stage transitions\n- Data transformations at each stage\n- Any control signals affecting pipeline flow\n- Reset behavior at each stage",
  "substeps": [{
    "id": 31,
    "desc": "Determine the signal naming conventions",
    "comment": "This would work better as a code analysis step that analyzes the entire codebase.",
    "must_produce": ["naming"],
    "prompt":
    "Analyze the signal names in the code, looking for any suffixes or prefixes that might indicate the nature of the signals. Any prefixes or suffixes used to group related logic are less important. Pay particular attention to the staging of signals in the code and its relation to the signal names. Popular naming conventions might identify pipelines and pipeline stages, or they might indicate that one signal is a staged version of another signal. There might be conventions that indicate whether signals change on the rising or falling edge of the clock or have unique behavior on either edge of the clock. One convention used by the conversion process thus far is the use of the prefix `NEXT_` for signals that will immediately be flopped.
    +
    +It is also common to use `i` or `o` to indicate input and output signals.
    +
    +Add an extra output field, called \"naming\", in your response that describes the signal naming convention."
  }, {
    "id": 32,
    "desc": "Data flow",
    "TODO": "This would work better as a code analysis step that analyzes the entire codebase.",
    "needs": ["naming"],
    "prompt":
    "Analyze the code to determine how data flows through the design. Add \"LLM: ...\" comments to the code to describe this data flow. Pay attention to high-level code comments that might describe the microarchitecture of the design. You also might get hints from signal naming conventions, as described below."
  }, {
    "id": 33,
    "desc": "Pipelines",
    "needs": ["naming"],
    "TODO": "Can't have optional 'pipelines' field.",
    "may_produce": ["pipelines"],
    "prompt":
    "Analyze the code to determine where the design uses pipelines. In this context a pipeline involves computations or processing that is stretched out over multiple clock cycles. It could even simply be the staging of data. This processing must flow freely without any form of backpressure or stalling to be considered part of the same pipeline. Determine meaningful names for the identified pipelines. Choose a pipeline stage numbering for each such pipeline (or if one has already been determined, keep it). The first pipeline stage with any appreciable logic can be identified as stage 1. Add \"LLM: ...\" comments to the code to annotate the code with these pipeline stages.
    +
    +If no pipelines are identified, add an extra output field to the response called \"pipelines\" with a value of \"none\".
    +
    +Pay attention to signal naming conventions that might indicate pipeline stages. These conventions have been analyzed and are described below."
  }, {
    "id": 34,
    "desc": "Eliminate unnecessary use of reset",
    "prompt":
    "Often, designers apply reset more aggressively than necessary. We want to use a reset methodology where reset will be asserted for a minimum of five cycles to initialize the circuit. Analyze all places where reset is applied to force a value on a signal during reset. See if you can determine the value the signal would have if reset were not applied to it directly. If it would be the same, remove the reset assignment."
  }, {
    "id": 35,
    "desc": "Stages",
    "needs": ["naming"],
    "prompt":
    "Apply a signal naming convention to signals that are part of pipelines. Pay attention to \"LLM: \" comments identifying pipelines and stage numbers. Use the naming convention <name>__<PIPELINE><stage>, e.g. pc__CPU_A3 for the program counter at stage 3 of a CPU pipeline. Use upper case for pipeline mnemonics like \"CPU\" and \"A\" (for at) before the stage number. Each such signal will have an associated pipeline mnemonic and stage number. Apply this consistently such that all flip-flops produce signals with names that differ only in that the output signal has an incremented stage number. This may require renaming signals in the code."
  }, {
    "id": 36,
    "desc": "Stage reset",
    "unless": {"pipelines": "none"},
    "prompt":
    "We would like to use a reset methodology where reset signals traverses pipelines as data would. A pipeline carries \"transactions\" that proceed to the next stage every clock cycle. The reset signal should also traverse the pipeline in the same manner. In other words, some transactions are reset transactions.
    +
    +Since `reset` is held for multiple cycles, there is usually no functional impact from applying `reset` after a delay. Where `reset` is applied to pipelined logic, pipeline the reset signal, and apply the staged version of the reset signal to the appropriate pipeline stage."
  }]
}, {
  "desc": "TL-Verilog-formatted signal names",
  "prompt": "Transform all signal names to strictly adhere to TL-Verilog naming conventions, ensuring compatibility with TL-Verilog pipesignal requirements and preparing for successful conversion.\n\n**TL-Verilog Naming Requirements:**\nSignals in TL-Verilog (called \"pipesignals\") must follow strict naming conventions:\n\n1. **Case Requirements:** All letters must be lowercase\n2. **Word Separation:** Words separated by underscores only\n3. **Number Placement:** Numbers can only appear directly following words (not standalone)\n4. **Minimum Length:** Names must be at least two characters long\n5. **Initial Characters:** First two characters must be letters\n6. **Valid Examples:** 'data_op2', 'mem_addr', 'cpu_state'\n7. **Invalid Examples:** 'DataOp', 'a', '2data', 'op_2_sel'\n\n**Systematic Name Transformation:**\nTransform existing signal names while preserving semantic meaning:\n\n```verilog\n// Original non-compliant names\nDataValid       → data_valid\nopCode          → op_code\na               → aa (or more descriptive name)\nPC              → pc\nmemAddr2        → mem_addr2\nCPU_State       → cpu_state\n```\n\n**Pipeline Signal Preservation:**\nFor signals with pipeline stage suffixes using the `<name>__<PIPELINE><stage>` convention (e.g., `pc__CPU_A3`), only modify the `<name>` portion before the `__`:\n\n```verilog\n// Preserve pipeline staging\nProgramCounter__CPU_A3  → program_counter__CPU_A3\ndataPath__MEM_A1        → data_path__MEM_A1\nopCode__DECODE_A2       → op_code__DECODE_A2\n```\n\n**Single Character Name Handling:**\nFor single-letter signal names, either:\n1. Use double letters if no semantic meaning is clear: `a` → `aa`\n2. Choose descriptive names based on usage context: `a` → `addr`, `d` → `data`\n\n**Systematic Transformation Process:**\n1. Identify all signal declarations and usages\n2. Check each name against TL-Verilog requirements\n3. Transform non-compliant names while preserving meaning\n4. Update all references throughout the module\n5. Preserve any pipeline stage suffixes\n\n**Validation:**\nEnsure all transformed names:\n- Are at least 2 characters long\n- Start with two letters\n- Use only lowercase letters, underscores, and trailing numbers\n- Maintain clear semantic meaning\n- Preserve pipeline stage information where applicable\n\nThis final naming step ensures complete compatibility with TL-Verilog conversion tools and maintains code readability.",
  "substeps": [{
    "id": 37,
    "desc": "TL-Verilog-formatted signal names",
    "background":
    "Signals in TL-Verilog are referred to as \"pipesignals\". They follow a specific naming convention:
    +
    +- Letters are lower case.
    +- Words are separated by underscores.
    +- Numbers can only appear directly following words.
    +- The name must be at least two characters long, and those first two characters must be letters.
    +
    +For example: 'data_op2'.",
    "prompt":
    "Update the names of signals in the design to adhere to the TL-Verilog naming convention. Some existing signals will have a suffix indicating their pipelines and pipeline stages. These use the naming convention <name>__<PIPELINE><stage>, e.g. pc__CPU_A3 for the program counter at stage 3 of a CPU pipeline. For these signals, correct the <name> portion without modifying the part after `__`. For single-letter signal names like `a`, consider using a more descriptive name or `aa`."
  }]
}]